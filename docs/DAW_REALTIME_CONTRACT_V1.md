# DAW Realtime Contract v1

> **Version**: 1.0  
> **Status**: Draft  
> **Owner**: A04 (Realtime Specialist)  
> **Audience**: A01 (Backend), A06 (Frontend), A02 (Audio Engine)  
> **Created**: 2026-01-11  

This document defines the realtime collaboration protocol for Ascend DAW. All collaborative features MUST adhere to this contract to ensure consistency, ordering, and conflict-free operation across multiple connected clients.

---

## Table of Contents

1. [Channel Strategy](#1-channel-strategy)
2. [Event Envelope](#2-event-envelope)
3. [Event Types](#3-event-types)
4. [Ordering & Idempotency Rules](#4-ordering--idempotency-rules)
5. [Payload Budgets & Throttling](#5-payload-budgets--throttling)
6. [Lock Semantics](#6-lock-semantics)
7. [Error Events](#7-error-events)
8. [Versioning Strategy](#8-versioning-strategy)
9. [Implementation Guidance](#9-implementation-guidance)

---

## 1. Channel Strategy

### 1.1 When to Use Each Transport

| Transport | Use Case | Latency | Reliability |
|-----------|----------|---------|-------------|
| **Supabase Realtime Broadcast** | Presence, cursors, typing indicators, non-critical UI sync | ~100-300ms | Best-effort |
| **Supabase Realtime Postgres Changes** | Database change notifications, project metadata | ~200-500ms | Guaranteed (via WAL) |
| **WebSocket Gateway** (future Sprint 1+) | Transport sync, low-latency collaboration, audio sync | <50ms target | Ordered, at-least-once |

### 1.2 Channel Naming Convention

All channels follow the pattern: `daw:{scope}:{resource_id}`

```typescript
// Channel name patterns
type DAWChannelName = 
  | `daw:project:${string}`    // Main project collaboration channel
  | `daw:presence:${string}`   // Presence-only channel (cursors, typing)
  | `daw:transport:${string}`  // Low-latency transport sync (WebSocket only)
  | `daw:audio:${string}`;     // Audio engine sync (future)

// Examples
const projectChannel = `daw:project:${projectId}`;      // "daw:project:550e8400-e29b-41d4-a716-446655440000"
const presenceChannel = `daw:presence:${projectId}`;    // "daw:presence:550e8400-e29b-41d4-a716-446655440000"
const transportChannel = `daw:transport:${projectId}`;  // "daw:transport:550e8400-e29b-41d4-a716-446655440000"
```

### 1.3 Subscription Patterns

#### Sprint 0: Supabase Realtime Only

```typescript
import { createClient, RealtimeChannel } from '@supabase/supabase-js';

interface ChannelSubscription {
  projectId: string;
  channels: {
    project: RealtimeChannel;   // For structural changes (tracks, clips, plugins)
    presence: RealtimeChannel;  // For ephemeral state (cursors, selections)
  };
}

// Subscription example
function subscribeToProject(supabase: SupabaseClient, projectId: string): ChannelSubscription {
  const projectChannel = supabase.channel(`daw:project:${projectId}`, {
    config: {
      broadcast: { ack: true },  // Require server acknowledgment
      presence: { key: clientId },
    },
  });

  const presenceChannel = supabase.channel(`daw:presence:${projectId}`, {
    config: {
      presence: { key: clientId },
    },
  });

  return { projectId, channels: { project: projectChannel, presence: presenceChannel } };
}
```

#### Channel Separation Rationale

| Channel | Event Types | Why Separate |
|---------|-------------|--------------|
| `daw:project:{id}` | track.*, clip.*, plugin.*, project.* | Structural changes need ordering guarantees |
| `daw:presence:{id}` | presence.*, cursor updates | High-frequency, best-effort, can be dropped |

---

## 2. Event Envelope

ALL collaboration events MUST use this envelope structure. No exceptions.

### 2.1 TypeScript Definition

```typescript
/**
 * Base envelope for all DAW collaboration events.
 * Every event sent through realtime channels MUST conform to this structure.
 */
interface DAWEventEnvelope<T extends string = string, P = unknown> {
  /** Unique event identifier. UUID v4, generated by the client. */
  event_id: string;

  /** Project this event belongs to. UUID. */
  project_id: string;

  /** User ID who triggered this event. From Supabase auth. */
  actor_id: string;

  /** 
   * Client instance ID. UUID v4 generated per browser tab/window.
   * Used for multi-tab detection and echo suppression.
   */
  client_id: string;

  /**
   * Server-assigned monotonic sequence number per project.
   * Starts at 1 for each project. Never resets.
   * Client-sent events have seq: 0 (server assigns real seq).
   */
  seq: number;

  /** ISO 8601 timestamp when client created the event. */
  sent_at: string;

  /** ISO 8601 timestamp when server received/processed the event. Server-assigned. */
  received_at: string;

  /** Event type. Dot-notation: "{domain}.{action}" */
  type: T;

  /** Schema version. Semantic versioning. Current: "1.0" */
  version: string;

  /** Event-specific payload. Structure depends on event type. */
  payload: P;
}

// Type helper for creating typed event envelopes
type TypedDAWEvent<T extends string, P> = DAWEventEnvelope<T, P>;
```

### 2.2 JSON Example

```json
{
  "event_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "project_id": "550e8400-e29b-41d4-a716-446655440000",
  "actor_id": "user_2nFj8kL9mPqR",
  "client_id": "c1d2e3f4-5678-90ab-cdef-1234567890ab",
  "seq": 0,
  "sent_at": "2026-01-11T14:30:00.123Z",
  "received_at": "",
  "type": "track.add",
  "version": "1.0",
  "payload": {
    "track_id": "trk_abc123",
    "name": "Vocals",
    "type": "audio",
    "index": 2
  }
}
```

### 2.3 Field Requirements

| Field | Set By | Required | Validation |
|-------|--------|----------|------------|
| `event_id` | Client | ✅ | Valid UUID v4 |
| `project_id` | Client | ✅ | Must exist, user must have access |
| `actor_id` | Client/Server | ✅ | Server validates matches auth token |
| `client_id` | Client | ✅ | Valid UUID v4, consistent per tab |
| `seq` | Server | ✅ | Client sends 0, server assigns real value |
| `sent_at` | Client | ✅ | Valid ISO 8601, not in future (5s tolerance) |
| `received_at` | Server | ✅ | Server assigns on receipt |
| `type` | Client | ✅ | Must be known event type |
| `version` | Client | ✅ | Must be supported version |
| `payload` | Client | ✅ | Must match schema for event type |

---

## 3. Event Types

### 3.1 Transport Events

Control playback state across all connected clients.

```typescript
// ─────────────────────────────────────────────────────────────
// transport.play
// ─────────────────────────────────────────────────────────────
interface TransportPlayPayload {
  /** Position in samples where playback starts */
  position_samples: number;
  
  /** Position in beats (for UI display) */
  position_beats: number;
  
  /** Timestamp when playback should start (for sync) */
  start_time: string;
}

type TransportPlayEvent = TypedDAWEvent<'transport.play', TransportPlayPayload>;

// Example
const playEvent: TransportPlayEvent = {
  event_id: "...",
  type: "transport.play",
  version: "1.0",
  payload: {
    position_samples: 44100,
    position_beats: 1.0,
    start_time: "2026-01-11T14:30:00.500Z"
  },
  // ... other envelope fields
};

// ─────────────────────────────────────────────────────────────
// transport.pause
// ─────────────────────────────────────────────────────────────
interface TransportPausePayload {
  /** Position where playback paused */
  position_samples: number;
  position_beats: number;
}

type TransportPauseEvent = TypedDAWEvent<'transport.pause', TransportPausePayload>;

// ─────────────────────────────────────────────────────────────
// transport.stop
// ─────────────────────────────────────────────────────────────
interface TransportStopPayload {
  /** Whether to reset position to 0 */
  reset_position: boolean;
}

type TransportStopEvent = TypedDAWEvent<'transport.stop', TransportStopPayload>;

// ─────────────────────────────────────────────────────────────
// transport.seek
// ─────────────────────────────────────────────────────────────
interface TransportSeekPayload {
  /** New position in samples */
  position_samples: number;
  position_beats: number;
  
  /** Whether transport was playing when seek initiated */
  was_playing: boolean;
}

type TransportSeekEvent = TypedDAWEvent<'transport.seek', TransportSeekPayload>;
```

### 3.2 Track Events

Manage track creation, modification, and arrangement.

```typescript
// ─────────────────────────────────────────────────────────────
// track.add
// ─────────────────────────────────────────────────────────────
interface TrackAddPayload {
  track_id: string;
  name: string;
  type: 'audio' | 'midi' | 'bus' | 'master';
  index: number;
  color?: string;          // Hex color code
  volume_db: number;       // Default: 0
  pan: number;             // -1 to 1, default: 0
  muted: boolean;          // Default: false
  soloed: boolean;         // Default: false
  armed: boolean;          // Default: false
}

type TrackAddEvent = TypedDAWEvent<'track.add', TrackAddPayload>;

// ─────────────────────────────────────────────────────────────
// track.update
// ─────────────────────────────────────────────────────────────
interface TrackUpdatePayload {
  track_id: string;
  /** Only include fields that changed */
  changes: Partial<{
    name: string;
    color: string;
    volume_db: number;
    pan: number;
    muted: boolean;
    soloed: boolean;
    armed: boolean;
  }>;
}

type TrackUpdateEvent = TypedDAWEvent<'track.update', TrackUpdatePayload>;

// ─────────────────────────────────────────────────────────────
// track.delete
// ─────────────────────────────────────────────────────────────
interface TrackDeletePayload {
  track_id: string;
  /** IDs of clips that were on this track (for undo) */
  deleted_clip_ids: string[];
}

type TrackDeleteEvent = TypedDAWEvent<'track.delete', TrackDeletePayload>;

// ─────────────────────────────────────────────────────────────
// track.reorder
// ─────────────────────────────────────────────────────────────
interface TrackReorderPayload {
  /** Ordered array of track IDs representing new order */
  track_order: string[];
}

type TrackReorderEvent = TypedDAWEvent<'track.reorder', TrackReorderPayload>;
```

### 3.3 Clip Events

Manage audio/MIDI clips on tracks.

```typescript
// ─────────────────────────────────────────────────────────────
// clip.add
// ─────────────────────────────────────────────────────────────
interface ClipAddPayload {
  clip_id: string;
  track_id: string;
  type: 'audio' | 'midi';
  name: string;
  
  /** Position on timeline (in samples) */
  position_samples: number;
  
  /** Duration of clip (in samples) */
  duration_samples: number;
  
  /** For audio clips: reference to audio file */
  audio_file_id?: string;
  
  /** Offset into source audio (for trimmed clips) */
  source_offset_samples?: number;
  
  /** Clip color (inherits from track if not set) */
  color?: string;
  
  /** Gain adjustment for this clip */
  gain_db: number;
  
  /** Fade in duration in samples */
  fade_in_samples: number;
  
  /** Fade out duration in samples */
  fade_out_samples: number;
}

type ClipAddEvent = TypedDAWEvent<'clip.add', ClipAddPayload>;

// ─────────────────────────────────────────────────────────────
// clip.move
// ─────────────────────────────────────────────────────────────
interface ClipMovePayload {
  clip_id: string;
  
  /** New track (if moving between tracks) */
  track_id?: string;
  
  /** New position on timeline */
  position_samples: number;
  
  /** Whether this is an intermediate drag update or final position */
  is_dragging: boolean;
}

type ClipMoveEvent = TypedDAWEvent<'clip.move', ClipMovePayload>;

// ─────────────────────────────────────────────────────────────
// clip.update
// ─────────────────────────────────────────────────────────────
interface ClipUpdatePayload {
  clip_id: string;
  changes: Partial<{
    name: string;
    duration_samples: number;
    source_offset_samples: number;
    color: string;
    gain_db: number;
    fade_in_samples: number;
    fade_out_samples: number;
    muted: boolean;
  }>;
}

type ClipUpdateEvent = TypedDAWEvent<'clip.update', ClipUpdatePayload>;

// ─────────────────────────────────────────────────────────────
// clip.delete
// ─────────────────────────────────────────────────────────────
interface ClipDeletePayload {
  clip_id: string;
  track_id: string;
}

type ClipDeleteEvent = TypedDAWEvent<'clip.delete', ClipDeletePayload>;
```

### 3.4 Plugin Events

Manage audio plugins on tracks.

```typescript
// ─────────────────────────────────────────────────────────────
// plugin.add
// ─────────────────────────────────────────────────────────────
interface PluginAddPayload {
  plugin_instance_id: string;
  track_id: string;
  plugin_id: string;           // Reference to plugin definition
  name: string;
  index: number;               // Position in plugin chain
  bypassed: boolean;
  preset_id?: string;          // Initial preset to load
  parameters: Record<string, number>;  // Parameter values
}

type PluginAddEvent = TypedDAWEvent<'plugin.add', PluginAddPayload>;

// ─────────────────────────────────────────────────────────────
// plugin.update
// ─────────────────────────────────────────────────────────────
interface PluginUpdatePayload {
  plugin_instance_id: string;
  changes: Partial<{
    name: string;
    bypassed: boolean;
    preset_id: string;
    /** Changed parameters only */
    parameters: Record<string, number>;
  }>;
}

type PluginUpdateEvent = TypedDAWEvent<'plugin.update', PluginUpdatePayload>;

// ─────────────────────────────────────────────────────────────
// plugin.remove
// ─────────────────────────────────────────────────────────────
interface PluginRemovePayload {
  plugin_instance_id: string;
  track_id: string;
}

type PluginRemoveEvent = TypedDAWEvent<'plugin.remove', PluginRemovePayload>;

// ─────────────────────────────────────────────────────────────
// plugin.reorder
// ─────────────────────────────────────────────────────────────
interface PluginReorderPayload {
  track_id: string;
  /** Ordered array of plugin instance IDs */
  plugin_order: string[];
}

type PluginReorderEvent = TypedDAWEvent<'plugin.reorder', PluginReorderPayload>;
```

### 3.5 Presence Events

Track user presence and cursor positions.

```typescript
// ─────────────────────────────────────────────────────────────
// presence.join
// ─────────────────────────────────────────────────────────────
interface PresenceJoinPayload {
  user_id: string;
  display_name: string;
  avatar_url?: string;
  color: string;            // Assigned collaboration color
  client_id: string;        // For multi-tab tracking
}

type PresenceJoinEvent = TypedDAWEvent<'presence.join', PresenceJoinPayload>;

// ─────────────────────────────────────────────────────────────
// presence.leave
// ─────────────────────────────────────────────────────────────
interface PresenceLeavePayload {
  user_id: string;
  client_id: string;
  reason: 'explicit' | 'timeout' | 'disconnect';
}

type PresenceLeaveEvent = TypedDAWEvent<'presence.leave', PresenceLeavePayload>;

// ─────────────────────────────────────────────────────────────
// presence.cursor
// ─────────────────────────────────────────────────────────────
interface PresenceCursorPayload {
  /** Timeline position in beats */
  position_beats?: number;
  
  /** Currently selected track ID */
  track_id?: string;
  
  /** Currently selected clip IDs */
  selected_clip_ids?: string[];
  
  /** View coordinates for non-timeline areas */
  view_coords?: {
    area: 'mixer' | 'piano_roll' | 'browser' | 'arrangement';
    x: number;
    y: number;
  };
  
  /** User's current activity */
  activity?: 'idle' | 'editing' | 'playing' | 'recording' | 'dragging';
}

type PresenceCursorEvent = TypedDAWEvent<'presence.cursor', PresenceCursorPayload>;
```

### 3.6 Project Events

Project-level settings changes.

```typescript
// ─────────────────────────────────────────────────────────────
// project.update
// ─────────────────────────────────────────────────────────────
interface ProjectUpdatePayload {
  changes: Partial<{
    name: string;
    bpm: number;
    time_signature_numerator: number;
    time_signature_denominator: number;
    sample_rate: number;
    loop_enabled: boolean;
    loop_start_samples: number;
    loop_end_samples: number;
    metronome_enabled: boolean;
    metronome_volume_db: number;
  }>;
}

type ProjectUpdateEvent = TypedDAWEvent<'project.update', ProjectUpdatePayload>;
```

### 3.7 Event Type Registry

```typescript
// Complete registry of all event types
type DAWEventType =
  // Transport
  | 'transport.play'
  | 'transport.pause'
  | 'transport.stop'
  | 'transport.seek'
  // Track
  | 'track.add'
  | 'track.update'
  | 'track.delete'
  | 'track.reorder'
  // Clip
  | 'clip.add'
  | 'clip.move'
  | 'clip.update'
  | 'clip.delete'
  // Plugin
  | 'plugin.add'
  | 'plugin.update'
  | 'plugin.remove'
  | 'plugin.reorder'
  // Presence
  | 'presence.join'
  | 'presence.leave'
  | 'presence.cursor'
  // Project
  | 'project.update'
  // Errors
  | 'error.rate_limit'
  | 'error.invalid_payload'
  | 'error.unauthorized'
  | 'error.version_mismatch';
```

---

## 4. Ordering & Idempotency Rules

### 4.1 Sequence Number Assignment

```
┌─────────────────────────────────────────────────────────────────┐
│                     Sequence Flow                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Client A              Server                  Client B          │
│     │                    │                        │              │
│     │ ─── event(seq:0) ──►│                       │              │
│     │                    │── assign seq:42 ──►   │              │
│     │ ◄── ack(seq:42) ───│                       │              │
│     │                    │── broadcast(seq:42) ──►│              │
│     │                    │                        │              │
│     │                    │◄─ event(seq:0) ────────│              │
│     │                    │── assign seq:43 ──►   │              │
│     │◄─ broadcast(seq:43)│                       │              │
│     │                    │── ack(seq:43) ────────►│              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**Rules**:
1. Server maintains a monotonic counter per project (never resets)
2. Client sends `seq: 0` (placeholder)
3. Server assigns next sequence number atomically
4. Server broadcasts event with assigned seq to all clients (including sender)
5. Sequence stored in database for replay capability

### 4.2 Gap Detection & Replay

```typescript
interface ClientSequenceState {
  projectId: string;
  lastSeenSeq: number;
  pendingEvents: Map<number, DAWEventEnvelope>;  // Buffer for out-of-order events
}

// Client-side gap detection
function handleIncomingEvent(state: ClientSequenceState, event: DAWEventEnvelope): void {
  const expectedSeq = state.lastSeenSeq + 1;
  
  if (event.seq === expectedSeq) {
    // Normal case: apply event
    applyEvent(event);
    state.lastSeenSeq = event.seq;
    
    // Check if we can apply buffered events
    while (state.pendingEvents.has(state.lastSeenSeq + 1)) {
      const buffered = state.pendingEvents.get(state.lastSeenSeq + 1)!;
      state.pendingEvents.delete(state.lastSeenSeq + 1);
      applyEvent(buffered);
      state.lastSeenSeq = buffered.seq;
    }
  } else if (event.seq > expectedSeq) {
    // Gap detected: buffer this event and request replay
    state.pendingEvents.set(event.seq, event);
    requestReplay(state.projectId, expectedSeq, event.seq - 1);
  }
  // event.seq < expectedSeq: duplicate, ignore
}

// Request replay from server
interface ReplayRequest {
  project_id: string;
  from_seq: number;  // Inclusive
  to_seq: number;    // Inclusive
}
```

### 4.3 Idempotency

**Rule**: Every event with the same `event_id` MUST produce the same outcome.

```typescript
// Server-side deduplication
interface EventDeduplication {
  // Store processed event IDs with TTL (24 hours)
  processedEvents: Map<string, { seq: number; processedAt: Date }>;
}

function processEvent(event: DAWEventEnvelope, dedup: EventDeduplication): ProcessResult {
  // Check if already processed
  if (dedup.processedEvents.has(event.event_id)) {
    const existing = dedup.processedEvents.get(event.event_id)!;
    return { 
      status: 'duplicate',
      originalSeq: existing.seq 
    };
  }
  
  // Process and store
  const seq = assignSequence(event.project_id);
  dedup.processedEvents.set(event.event_id, { seq, processedAt: new Date() });
  
  return { status: 'processed', seq };
}
```

### 4.4 Conflict Resolution

| Scenario | Resolution Strategy | Notes |
|----------|---------------------|-------|
| Concurrent property updates | Last-write-wins (by seq) | Server seq determines winner |
| Concurrent moves of same clip | Last-write-wins | Later seq overwrites position |
| Concurrent deletes | First delete wins | Second delete is no-op |
| Delete vs Update race | Delete wins | Updates to deleted entities are no-ops |
| Active drag (locked) | Lock holder wins | Others' edits are rejected |

```typescript
// Conflict resolution for concurrent updates
interface ConflictResolver {
  resolve(
    existingState: EntityState,
    incomingEvent: DAWEventEnvelope,
    existingSeq: number
  ): 'apply' | 'reject' | 'merge';
}

// Default: last-write-wins
function lastWriteWins(incoming: DAWEventEnvelope, existingSeq: number): 'apply' | 'reject' {
  return incoming.seq > existingSeq ? 'apply' : 'reject';
}
```

---

## 5. Payload Budgets & Throttling

### 5.1 Size Limits

| Limit | Value | Enforcement |
|-------|-------|-------------|
| Max single event payload | 64 KB | Server rejects with `error.invalid_payload` |
| Max event_id length | 36 chars | UUID format |
| Max string field | 1024 chars | Truncated or rejected |
| Max array items | 1000 | For track_order, plugin_order, etc. |

### 5.2 Rate Limits

| Limit | Value | Scope | Action on Exceed |
|-------|-------|-------|------------------|
| Events per second per client | 30 | Per client_id | Throttle + warning |
| Events per second per project | 100 | Per project_id | Throttle + warning |
| Burst allowance | 50 events | Per client, 1s window | Soft limit |
| Hard limit | 60 events/s | Per client | Disconnect |

### 5.3 Throttling & Coalescing

For high-frequency events (drag operations), implement client-side coalescing:

```typescript
interface ThrottleConfig {
  /** Minimum interval between events of same type */
  intervalMs: number;
  /** Whether to send final state on throttle end */
  sendFinal: boolean;
}

const THROTTLE_CONFIG: Record<string, ThrottleConfig> = {
  'clip.move': { intervalMs: 50, sendFinal: true },      // 20 updates/sec max during drag
  'presence.cursor': { intervalMs: 100, sendFinal: false }, // 10 updates/sec
  'plugin.update': { intervalMs: 100, sendFinal: true },    // Parameter automation
  'track.update': { intervalMs: 50, sendFinal: true },      // Fader movements
};

// Client-side coalescing example
class EventCoalescer {
  private pending: Map<string, { event: DAWEventEnvelope; timer: NodeJS.Timeout }> = new Map();

  coalesce(event: DAWEventEnvelope): void {
    const config = THROTTLE_CONFIG[event.type];
    if (!config) {
      // No throttling, send immediately
      this.send(event);
      return;
    }

    const key = `${event.type}:${this.getEntityId(event)}`;
    const existing = this.pending.get(key);

    if (existing) {
      // Update pending event, don't reset timer
      existing.event = event;
    } else {
      // Send immediately, then start throttle window
      this.send(event);
      const timer = setTimeout(() => {
        const final = this.pending.get(key);
        if (final && config.sendFinal) {
          this.send(final.event);
        }
        this.pending.delete(key);
      }, config.intervalMs);
      this.pending.set(key, { event, timer });
    }
  }

  private getEntityId(event: DAWEventEnvelope): string {
    const payload = event.payload as Record<string, unknown>;
    return (payload.clip_id || payload.track_id || payload.plugin_instance_id || '') as string;
  }

  private send(event: DAWEventEnvelope): void {
    // Send via channel
  }
}
```

### 5.4 Drag Event Handling

Special handling for drag operations to minimize network traffic:

```typescript
interface DragSession {
  entityType: 'clip' | 'track' | 'plugin';
  entityId: string;
  startPosition: number;
  currentPosition: number;
  lastSentPosition: number;
  throttleTimer?: NodeJS.Timeout;
}

// During drag: send coalesced updates
// On drag end: send final position with is_dragging: false
// Other clients see smooth movement with ~50ms updates
```

---

## 6. Lock Semantics

Locks prevent conflicting edits when a user is actively manipulating an entity.

### 6.1 Lock Types

| Lock Type | Scope | Use Case |
|-----------|-------|----------|
| `clip_edit` | Single clip | Dragging, trimming, fading |
| `track_edit` | Single track | Dragging track header, bulk operations |
| `plugin_edit` | Single plugin instance | Adjusting parameters via UI (not automation) |
| `selection_edit` | Multiple entities | Multi-select operations |

### 6.2 Lock Request/Response

```typescript
// ─────────────────────────────────────────────────────────────
// Lock Request (client → server)
// ─────────────────────────────────────────────────────────────
interface LockRequestPayload {
  lock_type: 'clip_edit' | 'track_edit' | 'plugin_edit' | 'selection_edit';
  entity_ids: string[];  // One or more entity IDs
  reason?: string;       // Optional: "dragging", "editing", etc.
}

type LockRequestEvent = TypedDAWEvent<'lock.request', LockRequestPayload>;

// ─────────────────────────────────────────────────────────────
// Lock Response (server → client)
// ─────────────────────────────────────────────────────────────
interface LockResponsePayload {
  request_event_id: string;  // Original request event_id
  granted: boolean;
  lock_id?: string;          // If granted, unique lock identifier
  expires_at?: string;       // ISO timestamp when lock expires
  held_by?: {                // If denied, who holds the lock
    user_id: string;
    client_id: string;
    display_name: string;
  };
  reason?: string;           // If denied, why
}

type LockResponseEvent = TypedDAWEvent<'lock.response', LockResponsePayload>;

// ─────────────────────────────────────────────────────────────
// Lock Heartbeat (client → server, while lock held)
// ─────────────────────────────────────────────────────────────
interface LockHeartbeatPayload {
  lock_id: string;
}

type LockHeartbeatEvent = TypedDAWEvent<'lock.heartbeat', LockHeartbeatPayload>;

// ─────────────────────────────────────────────────────────────
// Lock Release (client → server, explicit release)
// ─────────────────────────────────────────────────────────────
interface LockReleasePayload {
  lock_id: string;
}

type LockReleaseEvent = TypedDAWEvent<'lock.release', LockReleasePayload>;

// ─────────────────────────────────────────────────────────────
// Lock Released (server → all clients, broadcast)
// ─────────────────────────────────────────────────────────────
interface LockReleasedPayload {
  lock_id: string;
  entity_ids: string[];
  reason: 'explicit' | 'timeout' | 'disconnect';
}

type LockReleasedEvent = TypedDAWEvent<'lock.released', LockReleasedPayload>;
```

### 6.3 Lock Timing

| Parameter | Value | Notes |
|-----------|-------|-------|
| Heartbeat interval | 5 seconds | Client must send heartbeat |
| Lock timeout | 15 seconds | Without heartbeat, lock expires |
| Max lock duration | 5 minutes | Hard limit, forces release |
| Lock acquisition timeout | 2 seconds | Request times out if no response |

### 6.4 Lock State Machine

```
┌─────────────────────────────────────────────────────────────────┐
│                     Lock State Machine                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌──────────┐         request          ┌───────────┐           │
│   │          │ ─────────────────────────►│           │           │
│   │ UNLOCKED │                          │  PENDING  │           │
│   │          │◄───────────────────────── │           │           │
│   └──────────┘         denied            └───────────┘           │
│        ▲                                       │                 │
│        │                                 granted                 │
│        │                                       │                 │
│        │                                       ▼                 │
│        │               ┌───────────────────────────┐            │
│        │               │                           │            │
│        │ release/      │         LOCKED            │◄─┐         │
│        │ timeout       │                           │  │         │
│        │               └───────────────────────────┘  │         │
│        │                         │                    │         │
│        │                   heartbeat              heartbeat     │
│        │                         │                    │         │
│        └─────────────────────────┴────────────────────┘         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 6.5 Visual Feedback

When an entity is locked by another user:

```typescript
interface LockVisualState {
  entity_id: string;
  locked_by: {
    user_id: string;
    display_name: string;
    color: string;  // User's collaboration color
  };
  lock_type: string;
}

// UI should:
// 1. Show colored border/overlay on locked entity
// 2. Display lock holder's name on hover
// 3. Disable edit controls for locked entity
// 4. Show cursor/selection of lock holder
```

---

## 7. Error Events

All errors follow the same envelope structure with error-specific payloads.

### 7.1 Error Types

```typescript
// ─────────────────────────────────────────────────────────────
// error.rate_limit
// ─────────────────────────────────────────────────────────────
interface RateLimitErrorPayload {
  limit_type: 'client' | 'project';
  current_rate: number;
  limit: number;
  retry_after_ms: number;
  /** Event IDs that were dropped */
  dropped_event_ids: string[];
}

type RateLimitErrorEvent = TypedDAWEvent<'error.rate_limit', RateLimitErrorPayload>;

// Example
const rateLimitError: RateLimitErrorEvent = {
  type: 'error.rate_limit',
  payload: {
    limit_type: 'client',
    current_rate: 45,
    limit: 30,
    retry_after_ms: 1000,
    dropped_event_ids: ['uuid1', 'uuid2']
  },
  // ... envelope fields
};

// ─────────────────────────────────────────────────────────────
// error.invalid_payload
// ─────────────────────────────────────────────────────────────
interface InvalidPayloadErrorPayload {
  original_event_id: string;
  original_type: string;
  errors: Array<{
    path: string;      // JSON path to invalid field
    message: string;   // Human-readable error
    code: string;      // Machine-readable code
  }>;
}

type InvalidPayloadErrorEvent = TypedDAWEvent<'error.invalid_payload', InvalidPayloadErrorPayload>;

// ─────────────────────────────────────────────────────────────
// error.unauthorized
// ─────────────────────────────────────────────────────────────
interface UnauthorizedErrorPayload {
  original_event_id: string;
  reason: 'token_expired' | 'insufficient_permissions' | 'project_access_denied' | 'locked_by_other';
  required_permission?: string;
  lock_holder?: {
    user_id: string;
    display_name: string;
  };
}

type UnauthorizedErrorEvent = TypedDAWEvent<'error.unauthorized', UnauthorizedErrorPayload>;

// ─────────────────────────────────────────────────────────────
// error.version_mismatch
// ─────────────────────────────────────────────────────────────
interface VersionMismatchErrorPayload {
  original_event_id: string;
  client_version: string;
  server_min_version: string;
  server_max_version: string;
  action: 'upgrade_required' | 'downgrade_warning';
  upgrade_url?: string;
}

type VersionMismatchErrorEvent = TypedDAWEvent<'error.version_mismatch', VersionMismatchErrorPayload>;
```

### 7.2 Error Handling Guidelines

| Error Type | Client Action | User Notification |
|------------|---------------|-------------------|
| `rate_limit` | Pause sending, retry after delay | Toast: "Slow down! Too many changes." |
| `invalid_payload` | Log error, don't retry | Console error only (bug) |
| `unauthorized.token_expired` | Refresh token, retry | None (automatic) |
| `unauthorized.project_access_denied` | Redirect to home | Modal: "Access denied" |
| `unauthorized.locked_by_other` | Disable controls | Toast: "Edited by {name}" |
| `version_mismatch` | Prompt refresh | Banner: "Update available" |

---

## 8. Versioning Strategy

### 8.1 Version Format

```typescript
// Semantic versioning: MAJOR.MINOR
// MAJOR: Breaking changes (new required fields, removed fields, changed semantics)
// MINOR: Backward-compatible additions (new optional fields, new event types)

type ProtocolVersion = '1.0' | '1.1' | '2.0';  // etc.

// Current version
const CURRENT_VERSION: ProtocolVersion = '1.0';
```

### 8.2 Compatibility Matrix

| Client Version | Server Version | Compatibility |
|----------------|----------------|---------------|
| 1.0 | 1.0 | ✅ Full |
| 1.0 | 1.1 | ✅ Full (server ignores new fields) |
| 1.1 | 1.0 | ⚠️ Partial (client handles missing optional fields) |
| 1.x | 2.x | ❌ Incompatible (version_mismatch error) |

### 8.3 Backward Compatibility Rules

1. **Never remove required fields** in minor versions
2. **New fields must be optional** with sensible defaults
3. **New event types** are backward-compatible (old clients ignore them)
4. **Payload changes** must be additive only in minor versions
5. **Major version bumps** require migration period with dual support

### 8.4 Deprecation Process

```typescript
// Deprecation timeline (example)
interface DeprecationNotice {
  feature: string;
  deprecated_in: string;    // Version when deprecated
  removed_in: string;       // Version when removed
  replacement?: string;     // What to use instead
  migration_guide?: string; // URL to migration docs
}

// Example deprecation
const deprecations: DeprecationNotice[] = [
  {
    feature: 'clip.move.position_beats',
    deprecated_in: '1.1',
    removed_in: '2.0',
    replacement: 'clip.move.position_samples',
    migration_guide: 'https://docs.ascend.daw/migration/1.1-to-2.0'
  }
];
```

### 8.5 Version Negotiation

```typescript
// On connection, client sends supported versions
interface ClientHello {
  supported_versions: string[];  // ['1.0', '1.1']
  preferred_version: string;     // '1.1'
  client_info: {
    app_version: string;
    platform: string;
  };
}

// Server responds with negotiated version
interface ServerHello {
  protocol_version: string;      // Negotiated version
  server_version: string;
  features: string[];            // Enabled features
  deprecation_warnings?: DeprecationNotice[];
}
```

---

## 9. Implementation Guidance

### 9.1 For A01 (Backend)

#### Database Schema Requirements

```sql
-- Event log table for replay capability
CREATE TABLE daw_event_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES daw_projects(id) ON DELETE CASCADE,
  seq BIGINT NOT NULL,
  event_id UUID NOT NULL UNIQUE,
  actor_id UUID NOT NULL REFERENCES auth.users(id),
  client_id UUID NOT NULL,
  type TEXT NOT NULL,
  version TEXT NOT NULL DEFAULT '1.0',
  payload JSONB NOT NULL,
  sent_at TIMESTAMPTZ NOT NULL,
  received_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(project_id, seq)
);

-- Index for replay queries
CREATE INDEX idx_event_log_project_seq ON daw_event_log(project_id, seq);

-- Index for deduplication
CREATE INDEX idx_event_log_event_id ON daw_event_log(event_id);

-- Sequence counter per project
CREATE TABLE daw_project_sequences (
  project_id UUID PRIMARY KEY REFERENCES daw_projects(id) ON DELETE CASCADE,
  current_seq BIGINT NOT NULL DEFAULT 0
);

-- Lock table
CREATE TABLE daw_locks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES daw_projects(id) ON DELETE CASCADE,
  entity_ids TEXT[] NOT NULL,
  lock_type TEXT NOT NULL,
  holder_user_id UUID NOT NULL REFERENCES auth.users(id),
  holder_client_id UUID NOT NULL,
  acquired_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_heartbeat TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,
  
  -- Prevent same entity being locked twice
  EXCLUDE USING gist (project_id WITH =, entity_ids WITH &&) WHERE (expires_at > NOW())
);
```

#### Sequence Assignment (Atomic)

```typescript
// Use database transaction for atomic sequence assignment
async function assignSequence(projectId: string): Promise<number> {
  const result = await db.query(`
    UPDATE daw_project_sequences 
    SET current_seq = current_seq + 1 
    WHERE project_id = $1 
    RETURNING current_seq
  `, [projectId]);
  
  return result.rows[0].current_seq;
}
```

### 9.2 For A06 (Frontend)

#### Connection Manager

```typescript
class RealtimeConnectionManager {
  private supabase: SupabaseClient;
  private channels: Map<string, RealtimeChannel> = new Map();
  private sequenceState: Map<string, ClientSequenceState> = new Map();
  private eventCoalescer: EventCoalescer;
  private clientId: string;

  constructor(supabase: SupabaseClient) {
    this.supabase = supabase;
    this.clientId = crypto.randomUUID();
    this.eventCoalescer = new EventCoalescer();
  }

  async joinProject(projectId: string): Promise<void> {
    // Subscribe to project channel
    const channel = this.supabase.channel(`daw:project:${projectId}`, {
      config: { broadcast: { ack: true } }
    });

    channel
      .on('broadcast', { event: 'daw_event' }, (payload) => {
        this.handleIncomingEvent(payload as DAWEventEnvelope);
      })
      .subscribe();

    this.channels.set(projectId, channel);
    this.sequenceState.set(projectId, { projectId, lastSeenSeq: 0, pendingEvents: new Map() });

    // Request current state snapshot
    await this.requestStateSnapshot(projectId);
  }

  async sendEvent<T extends DAWEventType>(
    projectId: string,
    type: T,
    payload: PayloadForType<T>
  ): Promise<void> {
    const event: DAWEventEnvelope = {
      event_id: crypto.randomUUID(),
      project_id: projectId,
      actor_id: this.supabase.auth.user()?.id ?? '',
      client_id: this.clientId,
      seq: 0,  // Server assigns
      sent_at: new Date().toISOString(),
      received_at: '',
      type,
      version: '1.0',
      payload
    };

    // Apply throttling/coalescing
    this.eventCoalescer.coalesce(event);
  }

  private handleIncomingEvent(event: DAWEventEnvelope): void {
    // Skip our own events (already applied optimistically)
    if (event.client_id === this.clientId) {
      return;
    }

    const state = this.sequenceState.get(event.project_id);
    if (!state) return;

    // Apply with gap detection
    this.applyWithGapDetection(state, event);
  }
}
```

#### Optimistic Updates

```typescript
// Apply changes optimistically, reconcile on server response
class OptimisticStateManager {
  private pendingUpdates: Map<string, DAWEventEnvelope> = new Map();
  private store: DAWStore;

  applyOptimistic(event: DAWEventEnvelope): void {
    // Store pending update
    this.pendingUpdates.set(event.event_id, event);
    
    // Apply to local state immediately
    this.store.applyEvent(event);
  }

  confirmEvent(eventId: string, serverSeq: number): void {
    const pending = this.pendingUpdates.get(eventId);
    if (pending) {
      pending.seq = serverSeq;
      this.pendingUpdates.delete(eventId);
    }
  }

  rejectEvent(eventId: string, error: DAWEventEnvelope): void {
    const pending = this.pendingUpdates.get(eventId);
    if (pending) {
      // Rollback the optimistic update
      this.store.rollbackEvent(pending);
      this.pendingUpdates.delete(eventId);
      
      // Notify user
      this.showError(error);
    }
  }
}
```

### 9.3 Testing Checklist

- [ ] Event envelope validation (all required fields)
- [ ] Sequence gap detection and replay
- [ ] Idempotency (same event_id = no-op)
- [ ] Rate limiting triggers at correct thresholds
- [ ] Lock acquisition/release/timeout
- [ ] Lock heartbeat keeps lock alive
- [ ] Multi-tab detection via client_id
- [ ] Echo suppression (don't apply own events twice)
- [ ] Version mismatch handling
- [ ] Reconnection and state sync
- [ ] Coalescing reduces event volume during drags

---

## Appendix A: Quick Reference

### Event Type Cheat Sheet

| Domain | Events |
|--------|--------|
| Transport | `play`, `pause`, `stop`, `seek` |
| Track | `add`, `update`, `delete`, `reorder` |
| Clip | `add`, `move`, `update`, `delete` |
| Plugin | `add`, `update`, `remove`, `reorder` |
| Presence | `join`, `leave`, `cursor` |
| Project | `update` |
| Lock | `request`, `response`, `heartbeat`, `release`, `released` |
| Error | `rate_limit`, `invalid_payload`, `unauthorized`, `version_mismatch` |

### Limits Cheat Sheet

| Limit | Value |
|-------|-------|
| Max payload size | 64 KB |
| Client rate limit | 30 events/sec |
| Project rate limit | 100 events/sec |
| Lock heartbeat interval | 5 sec |
| Lock timeout | 15 sec |
| Max lock duration | 5 min |

---

## Changelog

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2026-01-11 | Initial contract specification |
