// Generates root-mapfile.md by aggregating all mapfile.md files in the repo.
// Usage: node devtools/update-root-mapfile.js

const fs = require('fs/promises');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');
const TARGET = path.join(ROOT, 'root-mapfile.md');
const MAPFILE_NAME = 'mapfile.md';
const IGNORED_DIRS = new Set(['.git', 'node_modules', '.turbo', '.next']);

async function walk(dir, acc) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isDirectory()) {
      if (IGNORED_DIRS.has(entry.name)) continue;
      await walk(path.join(dir, entry.name), acc);
    } else if (entry.isFile() && entry.name === MAPFILE_NAME) {
      const full = path.join(dir, entry.name);
      if (full.toLowerCase() === TARGET.toLowerCase()) continue; // skip target
      acc.push(full);
    }
  }
}

function parseFrontmatter(text) {
  if (!text.startsWith('---')) return null;
  const end = text.indexOf('\n---', 3);
  if (end === -1) return null;
  const raw = text.slice(3, end).trim();
  const lines = raw.split(/\r?\n/);
  const data = {};
  let currentKey = null;
  for (const line of lines) {
    if (!line.trim()) continue;
    const arrayItemMatch = line.match(/^\s*-\s+(.*)$/);
    if (arrayItemMatch && currentKey) {
      data[currentKey].push(arrayItemMatch[1].trim());
      continue;
    }
    const kvMatch = line.match(/^([A-Za-z0-9_]+):\s*(.*)$/);
    if (kvMatch) {
      const key = kvMatch[1];
      let value = kvMatch[2].trim();
      if (value === '') {
        data[key] = [];
        currentKey = key;
        continue;
      }
      // Parse bracket arrays: [a, b]
      if (value.startsWith('[') && value.endsWith(']')) {
        const inner = value.slice(1, -1).trim();
        data[key] = inner ? inner.split(',').map(v => v.trim()).filter(Boolean) : [];
      } else {
        data[key] = value;
      }
      currentKey = null;
    }
  }
  return data;
}

function formatArray(name, arr, lines) {
  if (!arr || arr.length === 0) return;
  lines.push(`- ${name}:`);
  for (const item of arr) {
    lines.push(`  - ${item}`);
  }
}

function formatField(name, value, lines) {
  if (!value) return;
  if (Array.isArray(value)) {
    formatArray(name, value, lines);
  } else {
    lines.push(`- ${name}: ${value}`);
  }
}

async function build() {
  const mapfiles = [];
  await walk(ROOT, mapfiles);
  const entries = [];
  for (const file of mapfiles) {
    const text = await fs.readFile(file, 'utf8');
    const meta = parseFrontmatter(text);
    if (!meta) continue;
    entries.push({ file, meta });
  }
  entries.sort((a, b) => (a.meta.path || a.file).localeCompare(b.meta.path || b.file));

  const out = [];
  out.push('**DO NOT MANUALLY EDIT THIS FILE! Generated by devtools/update-root-mapfile.js**');
  out.push('');
  out.push('# Project Map (auto-generated)');
  out.push(`Generated: ${new Date().toISOString()}`);
  out.push('');

  out.push('## Directory Index');
  for (const { meta } of entries) {
    const pathLabel = meta.path || 'unknown-path';
    const owner = meta.owner || 'unknown-owner';
    const summary = meta.summary || '';
    out.push(`- ${pathLabel} (${owner}) - ${summary}`);
  }
  out.push('');

  for (const { meta } of entries) {
    const pathLabel = meta.path || meta.file;
    out.push(`### ${pathLabel}`);
    const section = [];
    formatField('owner', meta.owner, section);
    formatField('status', meta.status, section);
    formatField('summary', meta.summary, section);
    formatField('last_updated', meta.last_updated, section);
    formatArray('key_artifacts', meta.key_artifacts, section);
    formatArray('processes', meta.processes, section);
    formatArray('dependencies', meta.dependencies, section);
    formatArray('risks', meta.risks, section);
    formatArray('todo', meta.todo, section);
    formatArray('tags', meta.tags, section);
    out.push(...section, '');
  }

  await fs.writeFile(TARGET, out.join('\n'), 'utf8');
  console.log(`Wrote ${TARGET} from ${entries.length} mapfiles.`);
}

build().catch(err => {
  console.error(err);
  process.exit(1);
});
