/**
 * Zod schemas for DAW realtime collaboration validation.
 * Based on DAW_REALTIME_CONTRACT_V1.md specifications.
 */

import { z } from 'zod';

// ============================================================================
// Event Envelope Schema
// ============================================================================

/**
 * Base envelope schema for all DAW collaboration events.
 * Every event sent through realtime channels MUST conform to this structure.
 */
export const DAWEventEnvelopeSchema = z.object({
  /** Unique event identifier. UUID v4, generated by the client. */
  event_id: z.string().uuid('event_id must be a valid UUID'),

  /** Project this event belongs to. UUID. */
  project_id: z.string().uuid('project_id must be a valid UUID'),

  /** User ID who triggered this event. From Supabase auth. */
  actor_id: z.string().uuid('actor_id must be a valid UUID'),

  /**
   * Client instance ID. UUID v4 generated per browser tab/window.
   * Used for multi-tab detection and echo suppression.
   */
  client_id: z.string().uuid('client_id must be a valid UUID'),

  /**
   * Server-assigned monotonic sequence number per project.
   * Starts at 1 for each project. Never resets.
   * Client-sent events have seq: 0 (server assigns real value).
   */
  seq: z.number().int().min(0),

  /** ISO 8601 timestamp when client created the event. */
  sent_at: z.string().datetime({ message: 'sent_at must be a valid ISO 8601 datetime' }),

  /** ISO 8601 timestamp when server received/processed the event. Server-assigned. */
  received_at: z.string().optional(),

  /** Event type. Dot-notation: "{domain}.{action}" */
  type: z.string().regex(/^[a-z]+\.[a-z_]+$/, 'type must be in format "domain.action"'),

  /** Schema version. Semantic versioning. Current: "1.0" */
  version: z.string().regex(/^\d+\.\d+$/, 'version must be in format "X.Y"'),

  /** Event-specific payload. Structure depends on event type. */
  payload: z.record(z.unknown()),
});

export type DAWEventEnvelope = z.infer<typeof DAWEventEnvelopeSchema>;

// ============================================================================
// Transport Event Payloads
// ============================================================================

export const TransportPlayPayloadSchema = z.object({
  position_samples: z.number().int().min(0),
  position_beats: z.number().min(0),
  start_time: z.string().datetime(),
});

export const TransportPausePayloadSchema = z.object({
  position_samples: z.number().int().min(0),
  position_beats: z.number().min(0),
});

export const TransportStopPayloadSchema = z.object({
  reset_position: z.boolean(),
});

export const TransportSeekPayloadSchema = z.object({
  position_samples: z.number().int().min(0),
  position_beats: z.number().min(0),
  was_playing: z.boolean(),
});

// ============================================================================
// Track Event Payloads
// ============================================================================

export const TrackTypeSchema = z.enum(['audio', 'midi', 'bus', 'master']);

export const TrackAddPayloadSchema = z.object({
  track_id: z.string().uuid(),
  name: z.string().min(1).max(255),
  type: TrackTypeSchema,
  index: z.number().int().min(0),
  color: z.string().regex(/^#[0-9a-fA-F]{6}$/).optional(),
  volume_db: z.number().min(-Infinity).max(12).default(0),
  pan: z.number().min(-1).max(1).default(0),
  muted: z.boolean().default(false),
  soloed: z.boolean().default(false),
  armed: z.boolean().default(false),
});

export const TrackUpdatePayloadSchema = z.object({
  track_id: z.string().uuid(),
  changes: z.object({
    name: z.string().min(1).max(255).optional(),
    color: z.string().regex(/^#[0-9a-fA-F]{6}$/).optional(),
    volume_db: z.number().min(-Infinity).max(12).optional(),
    pan: z.number().min(-1).max(1).optional(),
    muted: z.boolean().optional(),
    soloed: z.boolean().optional(),
    armed: z.boolean().optional(),
  }),
});

export const TrackDeletePayloadSchema = z.object({
  track_id: z.string().uuid(),
  deleted_clip_ids: z.array(z.string().uuid()),
});

export const TrackReorderPayloadSchema = z.object({
  track_order: z.array(z.string().uuid()),
});

// ============================================================================
// Clip Event Payloads
// ============================================================================

export const ClipTypeSchema = z.enum(['audio', 'midi']);

export const ClipAddPayloadSchema = z.object({
  clip_id: z.string().uuid(),
  track_id: z.string().uuid(),
  type: ClipTypeSchema,
  name: z.string().min(1).max(255),
  position_samples: z.number().int().min(0),
  duration_samples: z.number().int().min(1),
  audio_file_id: z.string().uuid().optional(),
  source_offset_samples: z.number().int().min(0).optional(),
});

export const ClipUpdatePayloadSchema = z.object({
  clip_id: z.string().uuid(),
  changes: z.object({
    name: z.string().min(1).max(255).optional(),
    position_samples: z.number().int().min(0).optional(),
    duration_samples: z.number().int().min(1).optional(),
    source_offset_samples: z.number().int().min(0).optional(),
  }),
});

export const ClipDeletePayloadSchema = z.object({
  clip_id: z.string().uuid(),
});

export const ClipMovePayloadSchema = z.object({
  clip_id: z.string().uuid(),
  target_track_id: z.string().uuid(),
  position_samples: z.number().int().min(0),
});

// ============================================================================
// Project Event Payloads
// ============================================================================

export const ProjectUpdatePayloadSchema = z.object({
  changes: z.object({
    name: z.string().min(1).max(255).optional(),
    bpm: z.number().int().min(1).max(999).optional(),
    time_signature: z.string().regex(/^\d+\/\d+$/).optional(),
    sample_rate: z.number().int().optional(),
    bit_depth: z.number().int().optional(),
  }),
});

// ============================================================================
// Event Type to Payload Mapping
// ============================================================================

export const EventPayloadSchemas: Record<string, z.ZodSchema> = {
  'transport.play': TransportPlayPayloadSchema,
  'transport.pause': TransportPausePayloadSchema,
  'transport.stop': TransportStopPayloadSchema,
  'transport.seek': TransportSeekPayloadSchema,
  'track.add': TrackAddPayloadSchema,
  'track.update': TrackUpdatePayloadSchema,
  'track.delete': TrackDeletePayloadSchema,
  'track.reorder': TrackReorderPayloadSchema,
  'clip.add': ClipAddPayloadSchema,
  'clip.update': ClipUpdatePayloadSchema,
  'clip.delete': ClipDeletePayloadSchema,
  'clip.move': ClipMovePayloadSchema,
  'project.update': ProjectUpdatePayloadSchema,
};

/**
 * Validates an event envelope including its type-specific payload.
 */
export function validateDAWEvent(event: unknown): {
  success: boolean;
  data?: DAWEventEnvelope;
  error?: z.ZodError;
} {
  // First validate the envelope structure
  const envelopeResult = DAWEventEnvelopeSchema.safeParse(event);
  if (!envelopeResult.success) {
    return { success: false, error: envelopeResult.error };
  }

  const envelope = envelopeResult.data;

  // Then validate the payload against its type-specific schema
  const payloadSchema = EventPayloadSchemas[envelope.type];
  if (payloadSchema) {
    const payloadResult = payloadSchema.safeParse(envelope.payload);
    if (!payloadResult.success) {
      return { success: false, error: payloadResult.error };
    }
  }

  return { success: true, data: envelope };
}

// ============================================================================
// WebSocket Message Types
// ============================================================================

export const WebSocketMessageTypeSchema = z.enum([
  'event',      // Regular collaboration event
  'ack',        // Server acknowledgment
  'error',      // Error response
  'sync',       // State sync request/response
  'ping',       // Keep-alive ping
  'pong',       // Keep-alive pong
]);

export type WebSocketMessageType = z.infer<typeof WebSocketMessageTypeSchema>;

export const WebSocketMessageSchema = z.object({
  type: WebSocketMessageTypeSchema,
  data: z.unknown(),
});

export type WebSocketMessage = z.infer<typeof WebSocketMessageSchema>;
