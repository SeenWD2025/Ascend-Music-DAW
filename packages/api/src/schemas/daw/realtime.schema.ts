/**
 * Zod schemas for DAW realtime collaboration validation.
 * Based on DAW_REALTIME_CONTRACT_V1.md specifications.
 */

import { z } from 'zod';
import { TrackTypeSchema } from './track.schema.js';
import { ClipTypeSchema } from './clip.schema.js';

// ============================================================================
// Event Envelope Schema
// ============================================================================

/**
 * Base envelope schema for all DAW collaboration events.
 * Every event sent through realtime channels MUST conform to this structure.
 */
export const DAWEventEnvelopeSchema = z.object({
  /** Unique event identifier. UUID v4, generated by the client. */
  event_id: z.string().uuid('event_id must be a valid UUID'),

  /** Project this event belongs to. UUID. */
  project_id: z.string().uuid('project_id must be a valid UUID'),

  /** User ID who triggered this event. From Supabase auth. */
  actor_id: z.string().uuid('actor_id must be a valid UUID'),

  /**
   * Client instance ID. UUID v4 generated per browser tab/window.
   * Used for multi-tab detection and echo suppression.
   */
  client_id: z.string().uuid('client_id must be a valid UUID'),

  /**
   * Server-assigned monotonic sequence number per project.
   * Starts at 1 for each project. Never resets.
   * Client-sent events have seq: 0 (server assigns real value).
   */
  seq: z.number().int().min(0),

  /** ISO 8601 timestamp when client created the event. */
  sent_at: z.string().datetime({ message: 'sent_at must be a valid ISO 8601 datetime' }),

  /** ISO 8601 timestamp when server received/processed the event. Server-assigned. */
  received_at: z.string().optional(),

  /** Event type. Dot-notation: "{domain}.{action}" */
  type: z.string().regex(/^[a-z]+\.[a-z_]+$/, 'type must be in format "domain.action"'),

  /** Schema version. Semantic versioning. Current: "1.0" */
  version: z.string().regex(/^\d+\.\d+$/, 'version must be in format "X.Y"'),

  /** Event-specific payload. Structure depends on event type. */
  payload: z.record(z.unknown()),
});

export type DAWEventEnvelope = z.infer<typeof DAWEventEnvelopeSchema>;

// ============================================================================
// Transport Event Payloads
// ============================================================================

export const TransportPlayPayloadSchema = z.object({
  position_samples: z.number().int().min(0),
  position_beats: z.number().min(0),
  start_time: z.string().datetime(),
});

export const TransportPausePayloadSchema = z.object({
  position_samples: z.number().int().min(0),
  position_beats: z.number().min(0),
});

export const TransportStopPayloadSchema = z.object({
  reset_position: z.boolean(),
});

export const TransportSeekPayloadSchema = z.object({
  position_samples: z.number().int().min(0),
  position_beats: z.number().min(0),
  was_playing: z.boolean(),
});

// ============================================================================
// Track Event Payloads
// ============================================================================

// TrackTypeSchema imported from track.schema.ts

export const TrackAddPayloadSchema = z.object({
  track_id: z.string().uuid(),
  name: z.string().min(1).max(255),
  type: TrackTypeSchema,
  index: z.number().int().min(0),
  color: z.string().regex(/^#[0-9a-fA-F]{6}$/).optional(),
  volume_db: z.number().min(-Infinity).max(12).default(0),
  pan: z.number().min(-1).max(1).default(0),
  muted: z.boolean().default(false),
  soloed: z.boolean().default(false),
  armed: z.boolean().default(false),
});

export const TrackUpdatePayloadSchema = z.object({
  track_id: z.string().uuid(),
  changes: z.object({
    name: z.string().min(1).max(255).optional(),
    color: z.string().regex(/^#[0-9a-fA-F]{6}$/).optional(),
    volume_db: z.number().min(-Infinity).max(12).optional(),
    pan: z.number().min(-1).max(1).optional(),
    muted: z.boolean().optional(),
    soloed: z.boolean().optional(),
    armed: z.boolean().optional(),
  }),
});

export const TrackDeletePayloadSchema = z.object({
  track_id: z.string().uuid(),
  deleted_clip_ids: z.array(z.string().uuid()),
});

export const TrackReorderPayloadSchema = z.object({
  track_order: z.array(z.string().uuid()),
});

// ============================================================================
// Clip Event Payloads
// ============================================================================

// ClipTypeSchema imported from clip.schema.ts

export const ClipAddPayloadSchema = z.object({
  clip_id: z.string().uuid(),
  track_id: z.string().uuid(),
  type: ClipTypeSchema,
  name: z.string().min(1).max(255),
  position_samples: z.number().int().min(0),
  duration_samples: z.number().int().min(1),
  audio_file_id: z.string().uuid().optional(),
  source_offset_samples: z.number().int().min(0).optional(),
});

export const ClipUpdatePayloadSchema = z.object({
  clip_id: z.string().uuid(),
  changes: z.object({
    name: z.string().min(1).max(255).optional(),
    position_samples: z.number().int().min(0).optional(),
    duration_samples: z.number().int().min(1).optional(),
    source_offset_samples: z.number().int().min(0).optional(),
  }),
});

export const ClipDeletePayloadSchema = z.object({
  clip_id: z.string().uuid(),
});

export const ClipMovePayloadSchema = z.object({
  clip_id: z.string().uuid(),
  target_track_id: z.string().uuid(),
  position_samples: z.number().int().min(0),
});

// ============================================================================
// Project Event Payloads
// ============================================================================

export const ProjectUpdatePayloadSchema = z.object({
  changes: z.object({
    name: z.string().min(1).max(255).optional(),
    bpm: z.number().int().min(1).max(999).optional(),
    time_signature: z.string().regex(/^\d+\/\d+$/).optional(),
    sample_rate: z.number().int().optional(),
    bit_depth: z.number().int().optional(),
  }),
});

// ============================================================================
// Plugin Event Payloads
// ============================================================================

/**
 * Payload for adding a new plugin to a track.
 */
export const PluginAddPayloadSchema = z.object({
  /** Plugin instance ID (UUID) */
  plugin_id: z.string().uuid(),
  
  /** Track this plugin belongs to */
  track_id: z.string().uuid(),
  
  /** WAM plugin identifier */
  wam_id: z.string().min(1).max(255),
  
  /** WAM plugin version */
  wam_version: z.string().regex(/^\d+\.\d+\.\d+$/),
  
  /** Position in the plugin chain (0-based) */
  position: z.number().int().min(0),
  
  /** Initial plugin state/preset data */
  state: z.record(z.unknown()).optional(),
  
  /** Plugin display name */
  name: z.string().min(1).max(255).optional(),
  
  /** Whether plugin is bypassed */
  bypass: z.boolean().default(false),
});

export type PluginAddPayload = z.infer<typeof PluginAddPayloadSchema>;

/**
 * Payload for updating plugin properties (state, bypass).
 */
export const PluginUpdatePayloadSchema = z.object({
  /** Plugin instance ID */
  plugin_id: z.string().uuid(),
  
  /** Changed properties */
  changes: z.object({
    /** Full plugin state update */
    state: z.record(z.unknown()).optional(),
    /** Bypass state */
    bypass: z.boolean().optional(),
    /** Plugin display name */
    name: z.string().min(1).max(255).optional(),
  }),
});

export type PluginUpdatePayload = z.infer<typeof PluginUpdatePayloadSchema>;

/**
 * Payload for individual parameter changes (high-frequency, throttled).
 */
export const PluginParamChangePayloadSchema = z.object({
  /** Plugin instance ID */
  plugin_id: z.string().uuid(),
  
  /** Parameter identifier (WAM param ID) */
  param_id: z.string().min(1).max(255),
  
  /** New parameter value (normalized 0-1 or actual value) */
  value: z.number(),
  
  /** Optional batch ID for coalescing multiple param changes */
  batch_id: z.string().uuid().optional(),
  
  /** Timestamp for ordering (ISO 8601) */
  timestamp: z.string().datetime().optional(),
});

export type PluginParamChangePayload = z.infer<typeof PluginParamChangePayloadSchema>;

/**
 * Payload for batched parameter changes (coalesced from rapid changes).
 */
export const PluginParamBatchPayloadSchema = z.object({
  /** Plugin instance ID */
  plugin_id: z.string().uuid(),
  
  /** Batch ID for idempotency and ordering */
  batch_id: z.string().uuid(),
  
  /** Map of param_id -> value for all changed parameters */
  params: z.record(z.string(), z.number()),
  
  /** Timestamp of the latest change in the batch */
  timestamp: z.string().datetime(),
});

export type PluginParamBatchPayload = z.infer<typeof PluginParamBatchPayloadSchema>;

/**
 * Payload for deleting a plugin from a track.
 */
export const PluginDeletePayloadSchema = z.object({
  /** Plugin instance ID to delete */
  plugin_id: z.string().uuid(),
  
  /** Track ID for validation */
  track_id: z.string().uuid().optional(),
});

export type PluginDeletePayload = z.infer<typeof PluginDeletePayloadSchema>;

/**
 * Payload for reordering plugins in a track's plugin chain.
 */
export const PluginReorderPayloadSchema = z.object({
  /** Track ID whose plugins are being reordered */
  track_id: z.string().uuid(),
  
  /** Ordered array of plugin instance IDs */
  plugin_order: z.array(z.string().uuid()),
});

export type PluginReorderPayload = z.infer<typeof PluginReorderPayloadSchema>;

// ============================================================================
// Event Type Enum
// ============================================================================

/**
 * All supported DAW event types.
 */
export const DAWEventTypeSchema = z.enum([
  // Transport events
  'transport.play',
  'transport.pause',
  'transport.stop',
  'transport.seek',
  // Track events
  'track.add',
  'track.update',
  'track.delete',
  'track.reorder',
  // Clip events
  'clip.add',
  'clip.update',
  'clip.delete',
  'clip.move',
  // Project events
  'project.update',
  // Plugin events
  'plugin.add',
  'plugin.update',
  'plugin.param_change',
  'plugin.param_batch',
  'plugin.delete',
  'plugin.reorder',
]);

export type DAWEventType = z.infer<typeof DAWEventTypeSchema>;

// ============================================================================
// Event Type to Payload Mapping
// ============================================================================

export const EventPayloadSchemas: Record<string, z.ZodSchema> = {
  'transport.play': TransportPlayPayloadSchema,
  'transport.pause': TransportPausePayloadSchema,
  'transport.stop': TransportStopPayloadSchema,
  'transport.seek': TransportSeekPayloadSchema,
  'track.add': TrackAddPayloadSchema,
  'track.update': TrackUpdatePayloadSchema,
  'track.delete': TrackDeletePayloadSchema,
  'track.reorder': TrackReorderPayloadSchema,
  'clip.add': ClipAddPayloadSchema,
  'clip.update': ClipUpdatePayloadSchema,
  'clip.delete': ClipDeletePayloadSchema,
  'clip.move': ClipMovePayloadSchema,
  'project.update': ProjectUpdatePayloadSchema,
  'plugin.add': PluginAddPayloadSchema,
  'plugin.update': PluginUpdatePayloadSchema,
  'plugin.param_change': PluginParamChangePayloadSchema,
  'plugin.param_batch': PluginParamBatchPayloadSchema,
  'plugin.delete': PluginDeletePayloadSchema,
  'plugin.reorder': PluginReorderPayloadSchema,
};

/**
 * Validates an event envelope including its type-specific payload.
 */
export function validateDAWEvent(event: unknown): {
  success: boolean;
  data?: DAWEventEnvelope;
  error?: z.ZodError;
} {
  // First validate the envelope structure
  const envelopeResult = DAWEventEnvelopeSchema.safeParse(event);
  if (!envelopeResult.success) {
    return { success: false, error: envelopeResult.error };
  }

  const envelope = envelopeResult.data;

  // Then validate the payload against its type-specific schema
  const payloadSchema = EventPayloadSchemas[envelope.type];
  if (payloadSchema) {
    const payloadResult = payloadSchema.safeParse(envelope.payload);
    if (!payloadResult.success) {
      return { success: false, error: payloadResult.error };
    }
  }

  return { success: true, data: envelope };
}

// ============================================================================
// WebSocket Message Types
// ============================================================================

export const WebSocketMessageTypeSchema = z.enum([
  'event',      // Regular collaboration event
  'ack',        // Server acknowledgment
  'error',      // Error response
  'sync',       // State sync request/response
  'ping',       // Keep-alive ping
  'pong',       // Keep-alive pong
  'presence',   // Presence updates (join/leave/update)
  'lock',       // Lock operations (acquire/release/heartbeat)
  'lock_response', // Lock operation response
]);

export type WebSocketMessageType = z.infer<typeof WebSocketMessageTypeSchema>;

export const WebSocketMessageSchema = z.object({
  type: WebSocketMessageTypeSchema,
  data: z.unknown(),
});

export type WebSocketMessage = z.infer<typeof WebSocketMessageSchema>;
